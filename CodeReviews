Charlie:
Readability Review:
Author: Charlie Cavallaro
Date: 9/28/2024
Sprint 2
#  Reviewing all three due to length of code #
BlockSprite.cs, CommNextBlock.cs, CommLastBlock.cs by TJ Blair
10 Minutes
The code is fairly readable with slightly sparse comments throughout the three classes, again due to the length and general simplicity of the code. There is an if statement in both Command classes that is simply commented with “allows blocks to loop,” the function seems clear but the need for the statement seems not super discernable.

Charlie:
Code Quality Review:
Author: Charlie Cavallaro
Date: 9/28/2024
Sprint 2
#  Reviewing all three due to length of code #
BlockSprite.cs, CommNextBlock.cs, CommLastBlock.cs by TJ Blair
Code of CommNextBlock and CommLastBlock have a slight DuplicatedCodeSmell, code is almost copy pasted the exact same, but I can see the reason for functionality. Maybe add a comment disclaimer. Code is overall not very smelly, due mostly to simplicity of the classes and what blocks do at the current state of the game. As I can discern, there is no Middleman smell, an ExpensiveSetUp smell, any WhileNotDoneLoop Smells or TooManyParameter passes. I believe there certainly will be a “YouDontNeedItAnymore” smell for future sprints, but as it is made in its current form, it is ok. The classes have a little bit of hidden coupling, with the execute() function being reliant on myGame.block to change the blocks. We see the execute command kind of “tell” not ask the block to change, which is a bit of a FeatureEnvy smell. 

My biggest problem comes in the fact that blocks are set up as just a sprite right now, this will certainly have to be refactored when it comes time to add collision and use blocks how they’re meant to be used. My suggestion is to create an IBlock interface that creates “block items” that control their sprite, instead of them just being a sprite. This gives us an area to handle collisions when we need to apply it for Sprint3. 

Overall, what you have is a solid basis for what we need, it will be easy to refactor into what we need and the code is very simple. Good job.

Wilson:
Readability Review
Author of the code review: Wilson Lin
Date of the code review: 9/27
Sprint number: 2
Name of the .cs file being reviewed: Aquamentus.cs
Author of the .cs file being reviewed: Noelle Lin
Number of minutes taken to complete the review: 15 minutes
Specific comments: Overall the readability is decent, variable names are reasonable and even without the comments it is not difficult to figure out what each variable does from a simple glance. The main difficult part of this file is just the sheer amount of variables being passed in through the method header and length of the file. Since it is quite large it effects readability when it can be split up into smaller portions for the boss.
Code Quality Review
Author of the code review: Wilson Lin
Date of the code review: 9/27
Sprint number: 2
Name of the .cs file being reviewed Aquamentus.cs
Author of the .cs file being reviewed Noelle Lin
Specific comments on code quality
First things first, Line 89 the line 
    	spriteBatch.GraphicsDevice.Clear(Color.CornflowerBlue);
can be deleted. This just changes the background color. It’s not really needed in draw. Another thing about draw usually spriteBatch is passed through Draw, however I see it being passed through your constructor. So with that spriteBatch.Begin() and .End() are not needed and you can directly use the spriteBatch passed through to draw.
Now onto code smells.
Negative Code Smells
1.  Long Method: I notice right away that the Update method does a lot of different things at once. The actions include fireball throwing, removing inactive sprites, animating the sprite, moving Aquamentus, and setting bounds for the boss. It is all just a lot for a single method and separate smaller methods could help increase readability and maintainability.
2. Large Class: This connects with Long Methods as the Aquamentus class is just handling too much at once in a single file. For the reasons stated before, I would recommend splitting the Aquamentus class into smaller classes. Mainly think about SRP.
3. Primitive Obsessions - I can see that there are quite a bit of primitives listed in the code. It’s not extremely excessive, but keep it in mind when we pursue later sprints.
4. Duplicate code - Duplicate code shows up at times in the file, but mainly important to spot that ThrowFireball is repeated 3 times in a row. This can be simplified using an abstraction. Mainly the point is if something is repeated in our game, rather than pasting the code multiple times abstraction can be used instead.
5. Long parameter list: Long parameter lists are hard to maintain and work with. Try to size down the parameter list for readability and maintainability purposes.
6. Dead code: We have some dead code at the bottom that is a part of DynamicSprite, it shouldn’t be an issue, but I thought I would raise awareness. This is something we will most likely implement in the future.

Positive Code Smells
7. Shotgun Surgery: Although everything is done in a few files, if a change were to break the code, Aquamentus seems quite isolated and it would not affect other classes.
8. Message chains: The file itself does not allow for much coupling and it is shown in the code that coupling will not be an issue for Aquamentus.
9. Feature Envy: Aquamentus is not reliant on anyone else besides themselves. It interacts with Fireball, but it seems to be encapsulated well.
10. Middle Man: No middle man found, it seems as though the data passed to Fireball is impactful.

TJ:
Readability Review:
Author: Timothy Blair
Date: 9/27/2024
Sprint 2
Class file: DamageAnimation.cs by Wilson
Time Taken: 10 minutes
Comments:
The variable maxCycles (line 17) does not have a comment explaining its purpose, while the variables before it do.
The code structure is very straightforward and easy to understand.
Some variable names could be slightly more descriptive to be understood out of context, but in context they all make sense.

Quality Review:
Author: Timothy Blair
Date: 9/27/2024
Sprint 2
Class file: DamageAnimation.cs by Wilson
Comments:
Duplicated Code: I don’t know if timeElapsed needs to be given a value in the constructor of DamageAnimation (line 31). I think StartDamageEffect is enough to initialize it.
Feature Envy Smell: The only thing outside of the class being accessed is gameTime.ElapsedGameTime.TotalSeconds, which is fine.
Verb Subject: Strictly following this code smell, StartDamageEffect should instead be a class DamageEffect with a method Start. However, this method just sets some variables without actually affecting the sprite, so perhaps only a better name is needed. Personally, I think it’s fine as is since setting the variables is what allows Update to go through the damage cycle.
Vague Identifiers: cycleCount and maxCycles are vague on what they mean in isolation. In the context of the code it is clear what the cycle refers to, but something like damageCycleCount and maxDamageCycles may be better.
Middle Man: Nothing wrong here, this class does everything it needs to itself.
Behavior To State: Good here, as of now there are no other classes that are similar to this. In fact, this class could likely be given to other sprites if we wish to have the same damage animation for them.
Law Of Demeter: Looks great, the class doesn’t directly change anything outside. It simply passes off the values it was told to get in GetCurrentColor.
Meaningful Names: Names look good. It is easy to understand the purposes of the variables in the given context.
Inappropriate Intimacy: Nothing wrong here, all is good in the world of DamageAnimation.
Backpedaling: Since this class doesn’t rely on anything outside of itself other than gameTime, it doesn’t need to check the state of anything else.
Ways to make the file better:
If damageColors could be changed to accept input from an outside file (like what we’ll end up doing for sprites in an xml file), we could be a lot more creative/flexible with the colors things flash when they take damage, especially if we put DamageAnimation on sprites other than Link. I think this would be a pretty easy change since damageColors is just a list currently. Other than that, the file looks really well done.


Vivian:
#WARNING THIS CODE REVIEW WAS WRITTEN ON A NON-FINALIZED VERSION OF LINK.CS#

Readability Review:
Author: Vivian Qian
Date: 9/28/2024
Sprint 2
Class file: Link.cs by Wilson and Charlie
Time Taken: 10 minutes
Comments:
There are still a few leftover bits like TODO lists written into the comments but thats minor.
Most of the fields at the top do not have a comment explaining their purpose although the names are largely self explanatory. Although I would like a comment on the purpose of Link having his own Game time. I like how there were comments left on why things are grouped a certain way and where that code may move in the future. Some item usage methods are empty and unexplained but that’s probably because it isn’t done yet. It doesn’t seem like Link’s game time is being used right now and it’s unexplained but probably has to do with the unimplemented items.


Quality Review:
Author: Vivian Qian
Date: 9/28/2024
Sprint 2
Class file: Link.cs by Wilson and Charlie
Comments:
1 Middle Man: I wouldn’t say Link is a middle man as although he does delegate some tasks to other classes, he holds all the pieces that make link work like his sprite and damage state and items to use. If these things tried to work together without link holding them together and giving them direction it would be very difficult.
2 Feature Envy: The only outside method link really calls are Update which makes sense since he owns some other objects and draw, which is fine since he needs the sprite he owns to be drawn.
3 Shotgun Surgery: This is difficult to tell without being the one to edit this class, but since link is so central to everything making changes to how link works would likely result in shotgun surgery on everything that has to do with Link like his commands and his items and his sprite that he owns.
4 Alternative Classes with Different Interfaces: This isn’t too applicable to Link I think. His functionality is decently unique and update and draw are common among most classes.
5 Primitive Obsession: I’m not sure if I understand this code smell very well, but this is something that pops up a lot in our code. For example we’re storing whether or not link is animated as a boolean and his position and direction as vectors which are relatively primitive. However, I feel that his state of animation should probably just be pushed to a sprite with 1 frame instead of getting rid of the ability of link to animate at all.
6 Temporary Field: Ignoring the item fields that are empty due to the fact that we’re still working on it, it looks like link’s fields are always either initialized on the creation of link or set themselves during the update that is guaranteed to run so it should be ok.
7 Large Class: Link does contain quite a few fields, but not that many lines of code. However this is definitely a concern that we should always be thinking about for link as he does act a bit like a connecting point for many aspects of the game as he is the main playable character.
8 Long Parameter List: None of link’s methods have more than 2 parameters, so I think this one is fine.
9:Refused Bequest: Link is the only class that implements I Link so this code smell is a bit less concerning since we can tailor ILink and Link to each other’s needs.
10: Data Class: Link isn’t a data class, but his rectangle data sheet definitely is, however we are already planning on making it a data file later so I’m not concerned.



Songyu:
Readability Review:
CODE REVIEW BY Songyu Ye
Date: 2024/9/27
Sprint 2
Class file:  SpriteItemAnimated.cs by Vivian
Comment:
Readability is generally good with well-structured methods and descriptive names, but there are some areas where improvement can be made to optimize the code (e.g., scaling magic number, width/ height recalculation). The class and method names are descriptive and self-explanatory, like Update(), Draw(), and SetSprite(), making it clear what functionality is being provided.


Readability Review:
CODE REVIEW BY Songyu Ye
Date: 2024/9/27
Sprint 2
Class file:  SpriteItemAnimated.cs by Vivian
Comment:
1. There are several instances of hardcoded values like 4 used for scaling, 0.3 for frame timing, and the index (currentFrame = 0). I think if you need to change the scale factor or frame timing, you'd have to search through the code and update every instance. So better use constants or configurable parameters to make these values clear and easier to modify.
2. The SetSprite() method is empty. The empty methods make the code more difficult to understand and increase the complexity unnecessarily.  Remove the method if it’s not needed. If it’s intended for future implementation, add a comment to make it clear that this is a placeholder.
3. The width and height of the sprite are recalculated for every frame in the Update() method, even though they only need to be updated when the frame changes. This causes unnecessary recalculations, making the code less efficient and harder to maintain. It also spreads logic that could be centralized. So I think for the future just calculate width and height only when the frame changes..
4. There is no check to ensure that spriteFrames is not null or empty. If the GetRectangleData() method returns null or an empty list, it could cause an exception when accessing the spriteFrames[currentFrame].Width. So I think just add null and empty checks for spriteFrames to prevent runtime errors.
5. The Update() method does more than just update the frame, such as recalculating width/height and handling time-based logic. The method is relatively small, but this pattern can become problematic as the class evolves. It can grow unwieldy over time and violate the Single Responsibility Principle. So just break the logic into smaller, reusable methods.
6. Another problem is that fields like itemTexture and spriteFrames are accessed directly within the class, which can make it harder to debug, test, or maintain the class. Direct field access is generally less flexible than using properties, which allows for validation or additional logic when setting or getting values. So better use properties instead of fields for better encapsulation in the future.
7. The method GetSprite() returns an index, which doesn’t match the method name’s expectation of returning a sprite or frame. Better rename GetSprite() to something more meaningful, like GetSpriteIndex() or GetCurrentFrameIndex(), to clarify its purpose.
8. The index field is set in the constructor and is only used once to initialize spriteFrames. After that, I think it’s never referenced again, which can clutter the class and lead to unnecessary complexity. Remove the index field and instead directly call SpriteItemData.GetRectangleData() during initialization if possible.
9. The class hardcodes constants like the frame timing (0.3) and scale factor (4) without providing a flexible way to adjust them for different sprite types. Maybe consider parameterizing or extracting these constants so they can be customized for different sprite types.
10. Add more comments to clarify the logic behind animations, scaling, and sprite drawing.



Noelle:
Author of the code review: Noelle Lin
Date of the code review: 9/27/2024
Sprint 2
The .cs file being reviewed: Goriya.cs by Songyu
Number of minutes taken to complete the review: 15 minutes
Comments:
What’s readable: The overall code is easy to read and to understand. The commenting is good. The variable naming is intuitive and self-explained. The methods are well-structured.
What could be improved: The code for setting the velocity, projectileOffset, and currentFrames in the ChangeDirection method could be refactored into a helper function “SetDirection” to reduce redundancy. Animation-related methods can be grouped together and can be separated from movement-related methods. Instead of having the initialization of the projectiles list inside of the constructor, it could be initialized at declaration for clarity and consistency. 

Author of the code review: Noelle Lin
Date of the code review: 9/27
Sprint 2
The .cs file being reviewed: Goriya.cs by Songyu
Specific comments on code quality:
Switch Statements: The ChangeDirection() method uses a switch statement to determine the movement direction and update the corresponding frames. It has duplicated logic and can be replaced with polymorphism.
Long Parameter List: The constructor of Goriya takes a long list of parameters, including SpriteBatch, Vector2, Texture2D, and many frame lists.This can be refactored by using parameter objects to bundle related parameters together.
Feature Envy: The ThrowProjectile() method heavily interacts with the Projectile class, constructing new projectiles and managing their states. Goriya is performing tasks that could be delegated to a separate ProjectileManager or to the Projectile class itself.
Inappropriate Intimacy: This class knows too much about how Projectile works managing both its position and state directly. The interaction with projectiles should be abstracted through an interface.
Data Clumps: The multiple List<Rectangle> parameters for frames in different directions (upFrames, downFrames, leftFrames, rightFrames, projectileFrames) are data clumps. These lists could be grouped into a new class to reduce redundancy.
Large Class (Large Number of Fields): The class has a large number of fields, which increases complexity and coupling. See which fields are necessary and which ones could be encapsulated.
Long method: The update method is too long and handles too many concerns (projectile management, animation, movement, boundary checking). It could be split into smaller, more focused methods.
Duplicate Code: The ChangeDirection method contains repetitive code for setting the velocity and frame updates for different directions. This can be refactored into a helper method “SetDirection” that reduces duplication.
Inconsistent Naming: The naming convention should be standardized. Methods like takendamage() and attack() should follow PascalCase and verb-based naming conventions (TakeDamage(), Attack()).
Shotgun Surgery: Multiple parts of the ChangeDirection() method need to be modified if we want to modify how direction changes are handled. To refactor, we could encapsulate the logic for handling direction changes into a separated method or class.
One potential change I could think of is to make Goriya more strategic by only throwing projectiles when link is in its line of sight, based on the direction Goriya is facing (up, down, left, or right). To implement this, we would need to add a reference to link’s position in the Goriya class (either by passing it in the constructor or accessing it during Update() ) and then add a check in ThrowProjectile() to see if link’s position is in the same line as Goriya’s current direction before throwing the projectile. The code we have now can handle this change, as Goriya tracks direction and throws projectiles. One potential challenge is that we might need to adjust the timing logic to prioritize checking if link is in the correct position before throwing, which could involve modifying cooldown and timing interactions.


